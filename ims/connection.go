package ims

import (
	"im_go/libs/bufio"
	"im_go/libs/proto"
	"net"
	"sync/atomic"
	"github.com/golang/glog"
	"time"
	"fmt"
	"errors"
)

type Connection struct {
	conn 		*net.TCPConn

	reader 	*bufio.Reader	//读取
	writer 	*bufio.Writer	//输出
	msg   	*Message
	closed 		int32

	online 		bool

	tc     		int32 //write channel timeout count


	//客户端协议版本号
	version 	int16

	wt 			chan *Message

	appId     	int64
	uId       	int64
	deviceId 	string
	deviceID 	int64 //generated by device_id + platform_id
	platformId 	int8

	count 		int32 //连接发送的消息数目：test
}

func (client *Connection)bufPrepare(conn *net.TCPConn)  {
	client.conn = conn
	reader := bufio.NewReaderSize(conn,int(proto.MaxPackSize))
	writer := bufio.NewWriter(conn)
	client.reader = reader
	client.writer = writer
	client.msg = new(Message)
}


func (client *Connection)read()(*Message,error)  {
	err := client.msg.ReadTCP(client.reader)
	return client.msg,err
}

func (client *Connection)send(msg *Message)error  {
	tc := atomic.LoadInt32(&client.tc)
	if tc > 0 {
		glog.Info("can't write data to blocked socket")
		return errors.New("can't write data to blocked socket")
	}
	return msg.WriteTCP(client.writer)
}

func (client *Connection)EnqueueMessage(msg *Message) bool {
	fmt.Println("EnqueueMessage",msg)
	closed := atomic.LoadInt32(&client.closed)
	if closed > 0{
		glog.Infof("can't send message to closed connection:%d", client.uId)
		return false
	}
	tc := atomic.LoadInt32(&client.tc)
	if tc > 0 {
		glog.Infof("can't send message to blocked connection:%d", client.uId)
		atomic.AddInt32(&client.tc, 1)
		return false
	}
	select {
	case client.wt <- msg:
		return true
	case <- time.After(60*time.Second):
		atomic.AddInt32(&client.tc, 1)
		glog.Infof("send message to wt timed out:%d", client.uId)
		return false
	}
}




func (client *Connection)close()  {
	atomic.StoreInt32(&client.closed, 1)
	client.conn.Close()
}


