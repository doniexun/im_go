package im

import (
	"net"
	"sync/atomic"
	log "github.com/golang/glog"

	"time"
)


const CLIENT_TIMEOUT = (60 * 6)


type Connection struct {
	conn  		*net.TCPConn

	closed 		int32

	tc     		int32 //write channel timeout count
	out 		chan *Proto


	tm     		time.Time

	appid  		int64
	uid    		int64
	device_id 	string
	device_ID 	int64 //generated by device_id + platform_id
	platform_id int8

}

func (client *Connection)read()*Proto  {
	client.conn.SetReadDeadline(time.Now().Add(CLIENT_TIMEOUT * time.Second))
	return ReceiveMessage(client.conn)
}

func (client *Connection)send(pro *Proto)  {
	tc := atomic.LoadInt32(&client.tc)
	if tc > 0 {
		log.Infof("can't write data to blocked socket")
		return
	}
	client.conn.SetWriteDeadline(time.Now().Add(60*time.Second))
	err := SendMessage(client.conn, pro)
	if err != nil {
		atomic.AddInt32(&client.tc, 1)
		log.Info("send msg:", OperationMsg(pro.Operation),  " tcp err:", err)
	}
}

// 根据连接类型关闭
func (client *Connection) close() {
	client.conn.Close()
}




//把消息加入到发送队列中
func (client *Client)EnqueueMessage(pro *Proto)bool {
	closed := atomic.LoadInt32(&client.closed)
	if closed > 0 {
		log.Infof("can't send message to closed connection:%d", client.uid)
		return false
	}
	tc := atomic.LoadInt32(&client.tc)
	if tc > 0 {
		log.Infof("can't send message to blocked connection:%d", client.uid)
		atomic.AddInt32(&client.tc, 1)
		return false
	}

	select {
	case client.out <- pro:
		return true
	case <- time.After(60*time.Second):
		atomic.AddInt32(&client.tc, 1)
		log.Infof("send message to wt timed out:%d", client.uid)
		return false
	}

}

